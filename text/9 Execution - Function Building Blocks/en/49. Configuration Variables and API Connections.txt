Right, so let's jump into Pichon. And the first thing I want us to do is just create another folder outside of strategies. I'm going to collapse strategy for a second. I'm going to right click on stuff, but on my project file and I'm going to create a new directory, and we're going to call this execution very straightforward and under strategy. I'm going to rename that main file here. So we go to refactor rename and I'm going to call that main underscore strategy. And the reason for that is not because we're going to change anything in this file. It's simply because I need to be able to see when I'm dealing with a strategy file or an execution file, because the reality is sometimes we're going to be in both. And I just want to make sure that I know which one I'm in and I'm not overwriting something I built before where I shouldn't be. So that's the first thing I'm going to do. Then in execution here, I'm going to create a new Python file, and we're going to call this main underscore execution. And there we go. So now we've got our main execution file, and I'm going to right click on that main execution tab and go close other tabs. So now I've just got that tab there and I'm going to print, you know, hello, start as just to test and make sure that this is compiling and running. So up here with its main strategy, I'm going to go edit configurations and the script path instead of it running. You know, from main strategy. I'm going to select for Stuttgart's execution that its main execution that is running and hit OK. Another way you can do that is just right click on there and go run main execution. That should also do it for you. And here I'm going to hit play. And there you go. Hello, Stuttgart's. So now it's going to be running anything within this execution folder. So we're going to treat this execution folder almost like it's its own separate project, even though it's within the same state bar project. But this is going to help us keep everything nice and separate and concise. So we know when we're dealing with, you know, strategy versus execution, and we're even going to duplicate some of the code from strategy and pipe it over to execution just to keep things packaged. No other reason other than that. And also, it's it can be a fact to refer to, you know, files in other folders, et cetera. So what I'd like to do or and in fact, on top of that, the other thing is you can sometimes change some code to do with the strategy with with and forget what impact it has in execution, for example. So it's another reason to do that. So what are we going to do here is I'm going to open the config strategy API in a minute, but before I do that, it's create a new Python file and let's pull that config execution underscore API and that will be the file we start coding in this double click on the strategy one and let's copy. I would say these two imports here, so I'm going to copy those there or just that one import and that string over there. So we're going to start with this and let's go down now and actually start going through the the variables, et cetera, that we want to create. So here I'm going to call this config variables just like the things we did before. And also I'm going to potentially code. I'll leave that open for now. Let's go to mode. Same thing we had before with creative mode and this will be test mode. And then, you know, ticker one is going to be equal to the ticker that we decided to go with. So if we go back to our backtesting file, we can see what the tick is. All right. So if we just go control left arrow, here we go matic USD T, that's going to be one and it's a control or command D. And this will be two two, which will be T, right? So these are the tickers we're going to use now. At some point here, we're going to stop using Matic and as to excuse the T, probably when we're playing with the limit orders because they might not be that liquid, they might not be that movement, that much movement for these coins. And so I might just for development purposes, switch it to like bitcoin versus Etherium, which are not integrated right now. But you know, there's so much trading that happens on them. I expect positions to get filled quickly, so we'll leave it at this for now, you know, with the intention that it will just work smoothly, but we might change it for development purposes down the line. And then we're going to create something here called signal positive signal positive ticker. And that is going to be equal to ticker. Ticket two. And what that means, then, is that the signal negative ticker, which I'm not even sure will end up using actually will be ticker one. What does that mean if we go back to our backtesting model here? Same thing as we had seen before. And if I just go to the right here, you'll see that we had, you know, go long with the Z scores negative symbol one. So when the Z score is positive, it's saying here if this, you know, if the signal i.e. the Z score is positive, what ticker should it be? And here I'm saying ticket to the reason I know that is because I've back tested which one works, which way. So symbol one simple to lose as money symbol one makes money. So the negative ticker will be symbol one. Positive ticker will be symbol two. So that's very important to get that right. Otherwise, your board can yield, you know, loss making results. You think it's your Botwin. Actually, it's to do with how you set up which target is going long and short. So the rounding to this is very important. What is the rounding for the ticker going to be? And that's what ticker ticker one and also for tickets to now, we've not set around. And yet I'm going to do this in a moment, but just leave this as an error for now and the quantity rounding it's a good one is going to be equal to what and the quantity rounding for ticket two is going to be equal to what. Now you might be thinking, OK, well, what's what is all of this about? So if you watch the series where I was trading on Bybit and, you know, talking about the order, book at least placing trade showing you how to place market orders, et cetera. I was talking about pay attention to the rounding. So now I'm going to go and actually make that a thing. So let's go to testnet bybit dot com. Let's go to derivatives, and I'm going to take a look here. So first thing is first, let's look at Matic USD T and analyze Matic USD t up here. So when I look at Matic USD T, I need to know multiple methods. It let me just see what this is. You may place an order by order, by quantity and order by cost. Okay, interesting. So if you look at Matic, there's some important things to realize here. The price is at four decimal places, so ticker one rounding needs to always be at four decimal places. We'll get two tickets here in a moment. The quantity has no decimal places. Zero. These are whole integers, whole numbers. So the rounding for ticker one is going to be zero is no, you know, there's no rounding on the quantity, right? So that's what that's doing. And then for SGX, what I want to do is I want to go and set that here. Now, you know, truthfully, you could also make the bot quite clever. One of the starting points where you know it figures out what the rounding is by running some kind of query to the symbol. But you know, I'm doing this here just to show you that the rounding is very important. So here we going to say, you know, the rounding here is three decimal places on the price and the quantity is one decimal place, right? You can see it dot 3.7. That's one decimal place. Now, SGX is interesting because actually clearly not much going on on SGX seems to be very slow, so I can already tell that getting limit orders filled here might be a time consuming task in terms of development. That doesn't mean you shouldn't do this. You know when you're running the bot live in testnet, but for development, I'm probably going to swap this out for like Etherium or something just to help you see things going, see things going through, essentially. And right now, you can even see I've got an open trade here. I've got two positions open Bitcoin Cash and X A. This is that other bot I told you about that was too good to be true. And look, yeah, it's losing your money. It's losing me money. And by the way, it's a good thing. It's a good thing to know. Its Y forward testing beats back testing hands down because it tells you. And also it could just be the change in market conditions I don't really know. But you know this here. Both of these trades are down right now, which is quite interesting. So, you know, when I'm doing this, you'll need to. If I have any open positions, this is just my other bot running. You'll have to just ignore those for now. But it'll be interesting for us to see, you know, is that bot losing money or making money? So that's that test bot that I told you it was going to run in the background. So just that's a side note. OK. Interesting. So we've got those tech around things in. And then the other thing here we want to do is just say, you know, is this going to be this bot going to work on a limit order basis? And I'm just going to say true for now. And what that means is, you know, place limit orders instead of market orders where you can. And so this will basically ensure that the positions except for in the order. Is a closed will be on a limited order? Actually, I'm just going to take a comment and whack this in here instead of you watching me typing out comments. I've got some comments. I'm just going to copy here to make life easier and also to note this for you so that, you know, when you download all this code from the project file you, you know what all of this is doing. So the next thing we want to do is, you know, set the tradable tradable capital USDC. So this is the total amount you know you want on any trade. So if we're going to pay it, what's the maximum amount of capital? This is down to you entirely down to you. I'm going to assume here $2000 because it makes numbers easy. So this will be two thousand USD T, and that means it will be one thousand for one pair and one thousand for another pair. So, you know, again, another comment for that, just to make sure that that's clear when you actually download the code and then, you know, stop loss failsafe. So this is, you know, kill, kill. Where do you want to place the stop loss? And I'm just going to say, you know, place it at 15 percent above or below, depending on whether you're going short or long, respectively. 15 percent of that just put a stop loss in, right? So I'm just going to do that for now. If you don't, if you're not interested in a stop loss because you're watching the market and you trust your board and it always executes, you know, then put this like 50 percent, but always have some kind of failsafe in there, just in case, just in case and then hit signal trigger threshold. This is important. This is what is the Z score need to be. This is the signal, you know, and this should be a positive number. This should always be above zero. Don't ever put a negative number here because the bot is smart enough to know if the Z scores negative or not, right? This is just the absolute Z score, and it works exactly the same as how our spreadsheet works. So we just copying our spreadsheet here, essentially. So that's what we going to do. We're going to put in one point one and that's going to be the Z score threshold. And again, I'm just going to put a note here for you because that's going to help you when it comes to actually going to keep this consistent and just put these lowercase. That's just going to help you to understand that that should always be above zero. And now we need to think about a few things. So you know, what is the timeframe? Or when we did the strategy, we used a time frame of 60, in other words, hourly bars, which I'm going to continue with. And again, that's just to help, you know, with the bot building ET daily would obviously take longer to see how trades execute. But we're going to use hourly here anyway. And then it's up to you how you want to do it. And you know this, this is an important note. You know, make sure that this matches your strategy whatever you used in your strategy. Just make sure it matches that. And then here we're going to have clean limit and that's going to be equal to 200 because we saw in the strategy session that is the maximum we can go to in terms of the API call. And then he had the Z score window. Again, this needs to match 21 because that's what we actually used for our strategy. So again, make sure it matches your strategy. Now we need to put in some information for our API. So I'm going to just go here to the previous API we had. I'm going to copy the live API, et cetera. I'm going to copy that over. So same, you know, key for testnet, same secret for testing. And we're going to be using those over here just like we did before. And then the next thing that we want to do is we want to set the URL as well. So here where we had, you know, the where were we the API key in secret? Sorry, let's take that here as well. Let's just copy this across. But we also then need to set the URL. So a copy that. And we'll also copy this URL here. In fact, we'll copy both of these because this is all going to be the same as what we did in our strategy. Now there's a couple of other things that we need to actually add in here. The first thing that we need to add is going to be our URLs for the web socket as well, because we're going to be using web sockets here. So the public URL for web socket is and we're not going to use the private one because we don't actually need it. We're just going to be using the public because the private calls we're going to make via the the actual API like we did before. But the web socket, we're going to use the public one because we want to use the web socket to stream prices over to us. So what is that URL? Well, if you remember back, we just need to go to our API documentation. So I'm going to go up here, open up our API documentation, go down to web socket data and. Here we go, so web socket testnet public. This is the URL that we need over here for testnet. And there it is. I'm going to scroll down here again and just say that that is equal to this URL. If mode is equal to test, just like we did before else, it needs to be equal to, you know, the public. Sorry, the private one. So here's the testnet Oh, sorry, not the private one. It needs to be then equal to the main net public one, which will be this one over here. So then otherwise it will use, you know, the main net public URL. So that's what we're doing there. And again, we don't need private, but if you want to make calls privately through web sockets, it's the same. Everything's the same. You just changes to private and then you can access your account. Information positions active orders through the web socket. But right now, I'm going to do all of that to rest and the market data I'm going to use, you know, through this website over here. So here we've got our session, which we had before, and I'm actually going to split this into two things now. I'm going to call the session public because we can have a public session. And we're also going to have a private session. So I'm going to create a duplicate of that and that's going to take an hour apart. URL. Sorry. API URL. And then we're going to take in our API key because it's private. We need a key. And that's going to be equal to the API key that we said above. And the API secret is going to be equal to the API secret above. And so that looks pretty good. So that's going to give us our sessions to access. And by now, you should know the difference between the public and the private market data. My account data, that's how we need to think about it. And that is good enough here for the config API file. The next thing we're going to do is to set up the web sockets. So I'll do that. I'll make that a short video and we'll call it that out into a separate video. So I'll see you over there now.