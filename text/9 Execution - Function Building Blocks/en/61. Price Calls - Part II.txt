OK, so now that we've got all timestamps, what we need to now be able to go and do is to get the historical prices and these will be the clients. So candles and nothing new to what we've done before. So this will be def get price declines. And this would be ticker that we will pass in this or before a specific ticker. And the first thing we're going to do here is get the prices and this we will need timestamps for. So what are we going to do is we're going to say our time start in seconds time. Start seconds or integer. I should have called up. I don't need the now price from above. I don't need the next price from above. Like I said, I'm not going to use those for the spot, so I'm just going to put, you know, underscores for those. And here I'm going to say is, you know, get timestamps. So that's what that's going to do and that will get all timestamps for us or our time timestamp from us. And then our prices is going to be equal to the session public dot query market or mark price climb. And that from the API on Bybit takes in a symbol. Just going to be able to take a it takes in an interval interval, which is going to be equal to time frame. And it takes in a limit which you've seen all of this before in the strategy section, which is the client limit. And it takes in a from time. And the whole point of us doing all those times from before was so that we could get the time start in seconds. So that will give us the prices. And then I just want to manage, you know, the amount of API calls in case I write something wrong. I'm just going to put a time to sleep even for 0.1 seconds, just as some protection against myself. And then here I'm going to return Price's output. So very, very straight forward here. So we're going to say if the length of the price is and this will be the result from those prices is not equal to the limit because it should be, then what? What are we going to want to do? We're going to want to return nothing same as we did before in the strategy to an empty array. Otherwise, return the prices results as follows. So that should work absolutely fine. So let's test this out. So let's put in get price coins. And let's put it for again, Matic is the one that I'm picking on. Pick on anything. And let's say that prices is equal to Matic Price Kline's, and let's print the prices and see how that looks over here. That should just run. So if we go ahead and run that and boom, there it is. So we've got all the prices there. 200, you know, days or hours in this case worth of data this I can get rid of this. That proves that the function is working just fine. And here what are we going to do is, you know, basically write a function to call this. So we're going to say, you know, get latest clients and it's going to do it for both tickets, right? So this is just going to be straightforward, which will, you know, get the latest clients and this will maybe be in a better way to test the above function. But it's fine. At least we know it's working. I'm going to say series one is going to be equal to an empty array. You're going to create a Series two because we want to get the prices for both. Put them in a series so we can check the Z score just like we did in the strategy section and then give prices one. It's going to be equal to get price climbs. I think it's going to be ticker one and the next one is going to be, you know, same thing here for prices to it's going to be get price clients and that will be for prices too. And then if the length of price is one because there should be length to it, if it's, you know, if it hit the client limit, if that length is greater than zero, then what we want is series one to be equal to extract close prices. Prices one. And that extract clothes prices. We're calling in at the top here. It's from the funky calculations. Here it is. It'll take all the prices, find the clothes price, put them in an array and return them, you know, return them back to us as such. And then we're going to do the same thing here. I'm going to copy all of that and I'm going to say prices to series, to extra clothes, prices, prices to try to make sure that you're always getting your tubes and your ones correct. And then here we're going to just return in a tuple. We will return to series one and we return the series to as such. So let's. Actually, go ahead and just put a print statement here for series one, and it's put another print statement here for Series two and call this get latest price declines and make sure that that has all worked just as we expected. So it's right click here. Run and boom, there they are, all the prices for Medicare and all the prices as well. What was the other one called Forgotten Stacks? We haven't spent much time talking about stocks. I'd forgotten what it was called, but that is working just fine. And that gives us some prices we can send over for calculating a Z score, so we won't do that quite yet. There's one more function for getting the liquidity to help us with limit orders, as we spoke about before finding the optimum liquidity to place a trade at. And we're going to do that first in the next session.