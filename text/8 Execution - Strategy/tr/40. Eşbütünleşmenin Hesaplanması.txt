Temel entegrasyon fonksiyonlarımız üzerinde çalışma zamanı. Aslında buraya gitmekte olduğumuz Funko entegrasyon dosyamızın en üstüne gideceğim ve aslında onu co bütünleştirmeyi hesapla fonksiyonuna koymaya başlayacağız, bilirsiniz, bir nevi CO bütünleştirmesini hesaplayın . Aşağıdaki gibi. Ve burada tam entegrasyonu hesapla demek için, afedersiniz, sadece giysi fiyatlarından sadece gidip çıkarabildiğimiz fiyatlardan bir Seri 1 ve Seri iki'yi geçmek demek istiyorum. Öyleyse bunu yapalım. Bir CO entegrasyon bayrağı ayarlayalım. Yani bu entegrasyon bayrağı sıfıra eşit olacak. Ve bunu bir şekilde açıklayacağım, bilirsiniz, kripto kullanan insanlar kripto kullanıyor mu, bunun yaptığı şeyle paralellikler kurabilmeleri için mi? Yani bu kadar hızlı bir şekilde kriptoya atlarsak, burada görebileceğiniz gibi egzama, USDC, T'den K'ye ve C USD T'ye sahibim. Bu, iki haftalık bazda saatlik, bilirsiniz, 200 zaman adımı değil Biliyorsunuz, şimdi botumuzla devam ediyoruz. Ancak bu kod entegrasyon bayrağı aslında bu yıl. Bu bir. Bu bir evet. Entegre ise hayır, değilse hayır. Ve sonra bu P değeri t değeri c değeri hedge oranı vardı. Bunların hepsi burada hesaplayacağımız şeyler. Korelasyonu bilmemize gerek yok. Biliyorsunuz, bunlar kriptonun korelasyonunu bilmek isteyen insanlar için buraya konulmuyor. Ama burada botumuz için bir karar vermemize yardımcı olmayacak. Yani esasen şimdi çekeceğimiz şey bu. Yine, bunun için kripto varlıklara ihtiyacınız yok. Sadece bu kursu yapan ve kriptoyu olduğu gibi kullanan bir sürü insan var ve bu onların bu uygulamadan kod entegrasyonunu kullanarak aslında kendileri için hesaplamak üzere olduklarını anlamalarına yardımcı oluyor. Yani aslında, bu, bilirsiniz, sadece bir yan not olarak, bu çok ilginç görünüyor. Sıfıra yayılma, genellikle şu anda büyük bir düşüş yaşadı. Bu nedenle, ilgilenen herkes için bu oldukça ilginç bir ticaret gibi görünüyor, ancak bu videoyu gördüğünüzde uzun zaman önce gitmiş olacak. Bu güzel bir tesadüf ve sanırım bunu bunun için yaptık. O halde hadi buraya geri dönelim ve kriptoyu kullanmanıza bile gerek kalmaması için bunu kodlamayı öğrenelim. Aslında gelip bu şeyleri kendin alabilirsin. Yani bu kod entegrasyon bayrağı basitçe şu anlama gelecek, entegre mi değil mi? Ve sonra burada istediğimiz şey, kod entegrasyon sonucunun Seri 1 ve Seri 2'nin madeni paralarına eşit olacağıdır. Peki Birinci Seri ve İkinci Seri'nin amacı nedir? Bu, henüz kütüphane olarak içe aktarmadığımız bir şey ve şimdi gidip bunu istatistik modellerinden almamız gerekiyor. Öyleyse ne yapacağız, buraya Python paketlerine gideceğiz ve denemeniz ve yapmanız gereken şey gitmek, bilirsiniz, pip install start modelleri. Bunu pip kurulumunun başladığı, modeller ve çalışması gerektiği gibi yapalım. Çalışmış gibi görünmelidir, vb. Ancak kursta daha önce söylediğim gibi, M1 Mac'te bununla ilgili çok fazla sorun yaşadım. Bu yüzden takvim ortamını kullanıyorum. Bu yüzden onu kaldırıp Conda olarak yeniden yüklemem bile gerekebilir. Aynı sorunu yaşıyorsanız, benim yaşadığım sorunla karşılaşırsanız, aynı şeyi yaşarsınız. Ama yüklemek için bir con yapmak için, sadece yüklemeye gidiyoruz, bilirsiniz, modeller.Yani aynı şeyi yapacak. Anaconda'da yapacak. Eğer şu anda benim gibi anakonda yorumcu iseniz, bizim gibi, bilirsiniz, kursta çok daha önce tartışmıştık. Şimdi yapacağımız şey aslında o importu içeri getirmek, yani, bilirsiniz, Stutz modellerinden dot, TSA Dot adım araçları, bu tür import kodları diyebiliriz. Yani bununla ilgili güzel olan şey, CO entegrasyonunu nasıl hesaplayacağınızı bilmek zorunda değilsiniz, değil mi? Hepsi senin için yapıldı. Tek yapmanız gereken, birinin fiyatlarını diğer varlığın fiyatlarını belirlemek için aynı fiyattan geçmek, aynı zaman damgaları için olduğundan emin olmak, aynı uzunlukta olduklarından emin olmak, zaten yaptığımız gibi ve bu CO entegrasyon sonucunuz gibi yapılır. Bu, şimdi zaten yapılmış olan kod entegrasyonunun hesaplanmasıdır. Yani T değeri mevcut sonuçlara eşit olacak. Yani temelde şu anki sonuçları alıp o dizideki ilk öğeyi almaya eşit olacak çünkü bu CO entegrasyon sonucu T değeri, p değeri ve tüm bu ilginç şeyleri içeren bir dizi döndürüyor. Yani bir sonraki aslında P'dir, bu haliyle P değeridir. Yani bu p değerini alacağız ve bu şu anki sonuç bir olacak. Bir de kritik değer olduğuna inandığım C değeri var. Bu yüzden bu kritik değeri arayacağım ve bu şu anki sonuçlara eşittir. Ve bu ikinci maddede. Ama sonra Öğe iki içinde başka bir dizi var. Bunu görmek için yazdırabilirsiniz. Zaman kazanmak için buraya yazacağım. Ama aslında, bu bir dizi içindeki ikinci diziye bakacak ve onu alacak. Madde ve bu bize mazeret verecek, o kritik değeri düzelteyim. Ve bunu bir kez elde ettiğimizde, yapmak istediğimiz şey bunu modelimizde çalıştırmak çünkü modelimizi kullanacağız, bir model aslında hedge artış oranını elde etmek için. Peki bu ne anlama geliyor? Doğru? modeli nedir? Çalıştıracağımız bu model nedir? Bu aslında istatistik modellerinden de geliyor. Yani başka bir kütüphane. Bu, istatistik modellerinden ve bu Dot API'dir ve bu, eSIM'i içe aktaracak. Ve orada yapacağımız şey bu. Ve bazı modellerde, eSIM'e eşit olacak ve daha küçük olacak. Oraya da koyacağımız eski bir Seri 1 ve Seri iki kullanacağız. Yani bu bizim için temel olarak hedge oranını hesaplayacak ve biz de modelimizi bu verilerle uyumlu hale getireceğiz. Şimdi, ben bir istatistik dahisi değilim. İstatistikleri sevdiğimi zaten biliyorsun ve birçok şeyle oynuyorum. Yaptığım ticarette sadece işe yarayan şeyi yapıyorum. Bunu böyle öğreniyorum, değil mi? Oh, esasen is olmadığı sürece, örneğin bir hedge oranı bulmak için sadece bir yöntemdir. Farklı pencerelerde kullanabileceğiniz farklı yöntemler ve yapabileceğiniz birçok şey var. Biliyorsunuz, CO entegrasyonunu hesaplarken, ama o zamanlar bunun daha az yaygınlaşmasının en mantıklı olduğunu düşündüm. Bu hedge oranını elde etmek için kullandığım şey buydu. Ve böylece devam edeceğim hedge oranı aslında ona eşittir model nokta paramlarına eşittir. Ve bu aynı zamanda bir dizi olduğundan ve o dizideki ilk öğe olduğundan. Bu yüzden ilk öğeyi almak için sıfır alıyoruz. Ve sonra yapmak istediğimiz diğer şey de yayılma gibi şeyleri elde etmek. Bu yüzden, bilirsin, yayılmayı da hesaplamak istiyorum. Yani aslında, diyeceğim ki, bilirsiniz, yayılma eşittir, muhtemelen buraya bir fonksiyon koyacağım ya da sadece yayılımı hesapla ve yayılımı hesaplamak için ihtiyacınız olan şey, aslında ihtiyacınız olan şey, bilirsiniz, seri bir, hepsi ilk sembolün yakın fiyatlarıdır. İkinci sembol ve riskten korunma oranımız için tamamı yakın fiyatlar olan ikinci seri,bunlar ihtiyacınız olan üç malzeme. Ve burada aslında yayılmayı bu şekilde hesaplamak için başka bir fonksiyon yaratacağım ve buna ölüm hesaplaması diyeceğiz. Bu şekilde yayılır ve bu, aşağıdaki gibi Seri bir, Seri iki seriden korunma oranı olacaktır. Doğru. Yani tek yaptığımız bu şeyi kendi işlevine geçirmek ve yayılmayı hesaplamak için yayılma temelde bir panda kıyafeti panda serisine eşit olacak. Esasen, yapmamız gereken panda ithal etmek. Pandaları kedicik olarak ithal edeceğim. Ve aslında, bu sorunu burada da fark ettim. eSIM'i içe aktarın. Yani bu yanlış. Bu, Stutz Modelleri API'sini olduğu gibi içe aktarmalıdır. Ve PD olarak ithal pandalar olmalı. Yani burada pandaları kullanacağız ve bu şekilde bir veri çerçevesi oluşturacağız. Ve bu gerçekten harika. Tek yapacağı, temelde bir Excel sütunu gibi eklemek. Bunu şöyle düşünebilirsiniz ve bu Excel sütununu alacak ve eksi başka bir Excel sütunu alacak, yani pandalar serileri başlatacak. Bunu böyle düşünebilirsiniz. Esasen burada yaptığımız şey bu. İkinci seri ve bunu hedge oranıyla çarpacağız. Yani yayılma temel olarak ilk sütun eksi ikinci sütun zamanlarının hesaplanmasıdır, kafa oranı. İşte bu kadar. Yayılmanın hesabı bu. Ve yayılmayı iade edeceğiz ve yayılma çok önemli bir şey. Yine de, bilirsiniz, gidip bunu hesaplamak bizim için ne kadar kolay oldu. Bu bize buradaki yayılmayı sağlıyor, ki bu çok, çok faydalı. Ve şimdi yapmak istediğimiz şey, aslında o yayılmada kaç kez sıfır geçiş olduğunu bilmek istiyorum. Doğru. Yani sıfırı geçerse, yani buradaki grafiğimize geri dönersem, örneğin, bu sadece bire iyi bir örnek. Birazdan kendi çizelgelerinizi nasıl oluşturacağınızı göstereceğim. Bu yüzden bir daha endişelenme. Bunu yapmak için platforma ihtiyacınız yok. Size nasıl yapılacağını göstereceğim, ama esasen gelecek. Çoğu zaman sıfır burada geçilir. Biliyorsunuz, bu fiyat ne kadar sıfır civarında seyrederse o kadar iyi. Ve bu yüzden bana bu numarayı veren bir şey istiyorum. Ve diyeceğim ki, bilirsiniz, sıfır geçişler uzunluğa eşit olacak ve bu hiç pasta olmayacak. Yani burada pastaya ihtiyacımız yok. NumPy'yi NP pastası olarak içe aktaracağız. Bu, bazı ilginç, bazı ilginç şeylerle bize burada yardımcı olacak başka bir kütüphane. Yani, pasta yapmadığımız yerde pasta yok diyeceğiz doc, nerede ve burada num pasta nokta farkını oldukça belirgin hale getireceğiz? Ve sonra pasta nokta işareti yok diyeceğiz. Ve burada yayılma diyeceğiz ve temelde sıfır diyeceğiz. Bu yüzden çok fazla endişelenme. Bu formül oldukça kafa karıştırıcı. Sadece olduğu gibi kopyalayın, ancak bu çok akıllıca bir yol. Aslında bu yolu borsada buldum. Bu, fiyatın kaç kez sıfıra indiğini temel olarak saymanın çok akıllıca bir yolu. Ve sonra yapacağımız şey, diyeceğiz ki, bilirsiniz, eğer P değeri sıfır nokta beşten küçükse, çünkü bunun kod entegrasyonu olarak kabul edilmesi gerekiyor ve bitcoin t kritik değerden küçükse, daha sonra ortak entegredir. O zaman mevcut bayrağın bire eşit olduğunu söyleyebiliriz çünkü biliyoruz ki, biliyorsunuz, bu doğru. Ve şimdi yapacağımız şey aslında tüm sonuçları döndürmek. Yani tüm bunları geri vereceğiz ve diyeceğiz ki, tamam, biliyorsunuz, Kore bayrağı, hadi Kore bayrağını geri verelim. Afedersiniz. Ayrıca P değerini de döndürelim ve bunu yuvarladım çünkü çok fazla ondalık basamak istemiyorum. Yani P değeri, aynı zamanda T değerini de döndürür. Ben de bunun etrafından dolaşıyorum. Yani bu da para birimi virgül olacak. Ve ayrıca geri dönmemiz gerekiyor. Bakalım. Kritik değeri de istiyoruz. Virgül iki. Ve bence, riskten korunma oranı oranı ve sıfır geçişi de bire gidiyoruz. Öyleyse bunu da yapalım. Hedge oranı. Ayrıca hedge oranını yuvarlayacağım. Bunu da iki ondalık basamağa kadar çalıştıracağım. Ve son olarak, sıfır geçişler, yani bunların hepsini geri getireceğiz, yani buraya integrasyon dediğimiz yere geldiğimizde,Yapmak üzere olduğumuz şey bu, temelde kakao entegrasyonu yapacağız ve Seri 1 ve Seri 2'de kalacağız. Bu, burada fonksiyonların bir fonksiyonuna gidecek, düşünmemize bile gerek olmayan tüm bu akıllı sihirbazlık ile entegrasyonu hesaplayacak. Devlerden çaldık, bilirsiniz, esasen devlerin omuzları üzerine inşa ettik ve onlardan çaldık. Ve sonra, bilirsiniz, burada yayılmayı hesaplayacağız, böylece sıfır geçişleri ve aynı zamanda yayılma bilgisini elde edebiliriz. Bu bizim için çok, çok kullanışlı olacak ve buraya geri dönecek. CO entegrasyonunu elde etmek için bu şekilde çalışır. Şimdi aslında bu ortak entegrasyonu almamız ve ona gerçekten bakabileceğimiz, anlamlandırabileceğimiz, test edilmiş onunla oynayabileceğimiz bir şekilde saklamamız gerekiyor. Bir sonraki videoda yapmak için doğru olduğundan emin olun.