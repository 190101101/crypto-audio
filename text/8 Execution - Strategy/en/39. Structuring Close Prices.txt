Now that we've got our price data, let's actually comment both of these sections of our code out because we don't actually want to go and run that anymore, we've got the price data that we can now analyze. And you know, if in the future, maybe a week from now, whatever, if you want to refresh this analysis or each day, refresh it, you can just run this section once a day, however you want to do it. But we don't need it right now. We're going to take the prices that we've calculated and that we've got here. As I showed you in the last video, we save this file with all of these prices, we're now going to start working with that price data. So let's put it here. You know, step three and the step three is going to be, you know, find co. integrated. And I'm sure there's a dash in integrated, but I don't want to spell it like that pairs, right? And what we want to do here is print. First of all, just like we did before, you know, print getting symbols, et cetera. So let's let's do a prince here. Let's copy that. And let's just say, you know, calculating co. I'll put a dash. I'm not too fast with spelling, with things like this, you know, calculating co integration. So that makes sense. And now we're going to open that file we've saved. And, you know, if we weren't saving a file, we could have just passed the data straight into, you know, this area. But because we wanted to save it now, we, you know, we have to be able to open it whenever we want. So we're going to do that. And the file is called one underscore price underscore list dot Jason as such. And now we don't need to do it right before we did sort of, you know, as a write by, we don't need that. So here we're just going to say, as you know, Jason file, and that's what we're going to do and we're going to say, OK, you know, the price data price data is equal to Jason Dot Load Jason File. Now it doesn't recognize Jason. You can see it's got that red underscore here. So what that means is, you know, we need to import Jason as such. So when we do that here, we've got Jason Dot Load, Jason File. And then what we're going to say is, you know, if the length, as you've guessed of the price data is greater than zero. In other words, if there is price data, then, you know, get the integrated pad. So I'm going to call this co into pairs is equal to, you know, get co integrated has price data as such. So that should be pretty good now. As usual, I wouldn't usually write a function like this without first having created it, but it's just so you can follow what's going on. So if we go over to our plan here, right, we've got the tradable symbols, we've got the price history. Now we're down at step three over here, you know, calculate code integration and that's before we go, you know, get the Spreads Z score, et cetera. So we're going to get this bit done here and that's where we are in the pipeline right now. So in order to do that, what I need to do is actually create a func another func file here. So we create this python file and we'll call it funk. And I'm going to call it Funk Echo integration, because this is going to be where all our code integration calculations live and we're going to do that. And so what we need to do is actually create a create a python function that is, you know, calculates cocoa integrated pest. As such. Sorry. As such, and so what are we going to do is we're going to go here, you know, get co integrated pest. So that's what we're going to call our function here. So I'm going to get rid of that. And also just make that lower casing. And here I'm also going to make, um, that's fine as it is there. That's fine. The good casing on a comment doesn't matter. It's just I tend to be, you know, quite pedantic about things sometimes. So here I'm going to say get co. integrated as such, and we're going to pass in the prices, right? Because over here we have price data. So we're going to pass that in and call it prices as such. And for now, I'm just going to put past going back to our main file. We need to actually import this in since I'm going to do that up here, I'm going to say, you know, from Func Co integration imports, get co integrated pears. And so no, that air is gone there and now we need to write out our function. So there's a number of things we're going to have to do here. And it's not all going to make sense at first, but the first thing I'm going to do is commenting, so you understand what's going on. We're going to loop through all the coins and check for CO integration. You know, that's what this function is doing. And to do that, we're going to initialize some variables. So I'm going to say, you know, the current list. So we're going to create an output of, you know, going pay this or variable for that. And we're also going to put in here an included list. And the reason we're doing an included list is similar to if you did the triangular arbitrage series. What we want to do is once we've included a pair, we found that's co integrated. We want to also put it in this list so that we don't loop through it and include it twice. It's to help us avoid duplicates. And I'm going to say, you know, for symbol one in prices, dot keys, we're going to leave through that simple one. So what does that mean? What is simple one? Actually, why don't we look? Let's put that out. Let's make sure everything's working. That'll be a great opportunity to do that. So let's print out simple one and see what's going on, right? Here's all of symbol one. What does that actually mean? Well, if we go to our Firefox file, each one of these is a key, right? And each one of these keys, therefore, is the symbol. The key is the symbol. And so we're looping through each one of these and we're calling it symbol one. So once we get to this first one, we're going to call it symbol one. Then we're going to loop through everything else and compare it to symbol one. Then we're going to get two simple two. Then we're going to loop through everything, including some what was symbol one before. But now that will be, you know, something else. We will call that symbol, too. It'll go through everything. So it will compare each one of these to everything else. Each one of these two, everything else. So that one to everything, that one to everything, that one to everything. And it's going to keep doing that. So it's a big loop that it's doing. And the reason it's doing that is because it wants to find every single possible combination of code integrated pairs that could be. And so that's what we're doing. So we're we're saying for every single symbol, one here in the keys, then what are we going to do here is I'm going to kind of coming up what I just said. So we're going to check each coin against the first. Someone, right, whatever the symbol one is at that point in time, if that makes sense, so here we're going to say for SIM two in prices dot keys. So it's the same file we're looking at. It's now we're saying, OK, we've got symbol one. But now what? Symbol two and symbol two is going to be everything else, right? So it's going to loop through everything else and compare it again. Symbol one, if some to as such is not equal to symbol one, then we need to do something with it. Why are we doing that? Because we don't want to compare symbol one against itself. So let's actually put this out to show you what it looks like. It's pronounced symbol one and symbol two and see what that looks like. Boom. That ran really quickly. So you can see, you know, his, for example, banned USD T, but it's comparing band used against every other coin. If you see that so he has the coin we doing, there's the one it's comparing to. There's going to be doing this, the one it's comparing to. If I scroll right up here, you know, here's bitcoin. Bitcoin's doing a two there and bitcoin's doing it to EOS bitcoins doing it to Bitcoin Cash. So that's what this over here is doing is it's essentially think of it as it's covering all bases. We're leaving no stone unturned and then we want to get a unique combination I.D. and ensure one off check. In other words, we don't want to duplicate things here. I've spelt immature incorrectly, so that's what we're going to do here. So we're going to say yes, sorted characters. You'll see the method to my madness again. If you did the triangular arbitrage course, you know exactly kind of what's going on here because you've you've done this before, simple one. Simple to whether this is best practice or not, I don't know, but it works, right? So here we go. And then we're going to say unique is equal to Dogecoin, and this might be confusing to you right now, but don't worry, it's going to make sense in a minute. Sorted characters and then, if unique. Sorry. If you look over here, if you Nick in included list, then break, what does that mean? So what we're saying is let's join these two things together and sort them in alphabetical order so that no matter what combination of these coins pops up, let's say you get to E30 to then it compares it to bitcoin used, which will happen. We don't want that right. We don't want it. We don't want it twice, just because it's in a different order to how it is now. So what we're doing is saying, let's put all of this into a string and sort the the joint concatenation of both of these strings alphabetically because that will create a unique ID. Both times, and therefore, that is what we're going to store, you know, in our included list. So in a minute, we're going to actually add this unique thing to our included list. And therefore, if it comes up again, it's going to break. So it's not, it's going to break out of this. This item here, this four simple two item here. That's essentially what's going to happen. Now what you can try doing actually is hitting continue because technically speaking, continue should ignore everything and just come back here. So instead of breaking it and jumping back up to this one, it should just continue looping through all the others. Now I'm going to use Break for now because I don't want to list which is too massive. And actually this should reduce the break. But you can use continue if you want to, so you can use continue like such and that way you don't leave any stone unturned here. I'm actually going to use break. I think break is probably correct. I'm going to do that for now and just make sure you're not getting any duplicates at the end of the day. This method that I'm showing you now is going to return so many options anyway. You're not going to know what to do with all of them. So. So that's fine for now. And then here are we going to say, you know, get close prices and this is going to be series one. That's what we're going to call the list of of prices. And what are we going to do is actually write a function. I'm going to call it extract clothes prices because we need a function to help us with this and we'll pass in the prices for this symbol, right? And that'll be symbol one and we'll do another one for symbol two. And so what this is going to do is put only the clothes prices into like an array and that's going to help us pass that. Then we'll take that array, pass it into like ACO integration calculation, essentially, which will be, you know, really handy. So think what we need to do here before we end this video is let's extract the clothes prices and then we can, you know, in the next video, go on to create the function for CO integration. So up here, I'm above this. I'm going to create another function as such, and I'm going to call this put clothes prices into an ordered list. Or let's just put into it into a list. And here I'm going to say def extract clothes, prices as such, and that'll be the prices. And then what I want to do here is, say Coke, you know, clothes prices will make that equal to an MTA, right? And I'll say full price values in prices. What we're going to do is say if the math and in fact, I think I need to then import -- abuse or import --. We'll say if -- dot is not a number, so is nine means it's not a no. Price values close. So this is just making sure that this is an a no higher price values and this is the close price that we're trying to get. So I'm going to explain this more intuitively in a moment, you know, then return this. In other words, if this missing prices or something funky with the price don't return any clothes. Prices will move past that point. Otherwise, close prices depend and we'll say, you know, price values close and such. And then we will return over here, the clothes prices. So that's what we're going to do over here. We're actually going to get the the clothes prices as such. And in fact, let's before we return it, let's actually just print the clothes prices so we can check that that's working nicely. And before we do that, let's just remind ourselves what we're doing. So we're getting for. Let's say we're starting with these two right bitcoin USD t. If I break open this level zero here, you can see here's the closing price. That's the price I wanted to compare to the other coin. So if we then, you know, close BTC USD to open up a.m. USD t, I wanted to compare that first closed price to this first close price and to do that for all 200 on each of those coins, for every single combination of all these coins. I'd say every combination, but actually I'm breaking it here. So it's going to break this this cycle over here. You know, once it gets to a duplication. So that's, you know, that's something that we're going to do that and what we should get out of that is, you know, this series one and Series two. So let's go and hit play there. And it's just there's an issue here. So sordid expected one argument got two. So let's have a look here at my SIM one and some two. So I think what's going on is I've passed these in or I haven't joined them together. I've put a comment by them. So what we need to do is add those together to join those two symbols together, right? That's how they get sorted alphabetically. So that's what we're doing. We're sorting those cards alphabetically. Now, let's try and run that. Oh, that's just so much data. I'm going to stop running it. He has all these closed prices, right? They're all being put into their own lists right now. So we've just got like a ridiculous amount of data. But that's what's happening. You've got a list of prices here being compared to a list of prices here in the same order with the same amount of prices being returned. So in the next video, what are we going to do is create the CO integration function and we're then going to pass these prices into that code integration function. And that's going to tell us whether this pair that we've got here is great integrated and we're going to do that for every pair. So that's what we're going to do next.